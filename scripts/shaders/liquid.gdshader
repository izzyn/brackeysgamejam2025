shader_type spatial;

render_mode unshaded;

uniform float slide_speed = 0.3;
uniform float wobble_speed = 1.0;
uniform float wobble_intensity = 0.4;
uniform float texture_scale = 0.2;
uniform sampler2D water : repeat_enable;

uniform sampler2D depth_texture : source_color, hint_depth_texture;

// Emission controls
uniform vec3 emission_color : source_color = vec3(0.0, 0.5, 1.0);
uniform float emission_strength : hint_range(0.0, 5.0) = 0.5;
uniform float emission_depth_fade : hint_range(0.0, 10.0) = 2.0;

varying vec2 sample_choord;

void vertex() {
	VERTEX.y += sin(TIME * wobble_speed + (VERTEX.x + VERTEX.z) * 0.1) * 0.3;
	sample_choord = VERTEX.xz;
}

void fragment() {
	vec3 color1 = vec3(1,1,1);
	vec3 color2 = texture(
		water,
		vec2(
			(sample_choord.x + sin(TIME * wobble_speed) * wobble_intensity + TIME * slide_speed) * texture_scale,
			(sample_choord.y + cos(TIME * wobble_speed * 0.1) * wobble_intensity) * texture_scale
		)
	).rgb;

	float depth = texture(depth_texture, SCREEN_UV).x;
	vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth);
	vec4 view = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;

	float object_depth = FRAGCOORD.z;
	vec3 object_ndc = vec3(SCREEN_UV * 2.0 - 1.0, object_depth);
	vec4 object_view = INV_PROJECTION_MATRIX * vec4(object_ndc, 1.0);
	object_view.xyz /= object_view.w;
	float linear_object_depth = -object_view.z;

	// Calculate depth-based alpha for water transparency
	float depth_factor = smoothstep(0.0, 0.5, linear_depth - linear_object_depth);
	ALBEDO = mix(color1, color2, depth_factor);
	
	// Add emission based on water texture brightness and depth
	float brightness = dot(color2, vec3(0.299, 0.587, 0.114));
	float emission_factor = brightness * emission_strength * smoothstep(0.0, emission_depth_fade, linear_depth - linear_object_depth);
	EMISSION = emission_color * emission_factor;
}