[gd_scene load_steps=12 format=3 uid="uid://nr2tf4wtfjoh"]

[ext_resource type="PackedScene" uid="uid://olw3xcvggj4m" path="res://assets/models/objects/book_shelf.glb" id="1_yohl2"]
[ext_resource type="Texture2D" uid="uid://bgu4vpgii4ly8" path="res://assets/textures/objects/bookshelfDiffuse.jpg" id="2_y62cx"]
[ext_resource type="Texture2D" uid="uid://cowhlxelhdsr" path="res://assets/textures/environment/stonetileAO.bmp" id="3_ap11n"]
[ext_resource type="Texture2D" uid="uid://s4ckdg14o7ay" path="res://assets/textures/objects/bookshelfSpec.png" id="4_wbtk3"]
[ext_resource type="Texture2D" uid="uid://c10hkgfpep1fc" path="res://assets/textures/objects/booksDiffuse.jpg" id="5_873ek"]
[ext_resource type="Texture2D" uid="uid://c56nmrnv5wlol" path="res://assets/textures/objects/booksSpec.png" id="6_vj0s6"]

[sub_resource type="Shader" id="Shader_duuov"]
code = "shader_type spatial;

//render_mode ambient_light_disabled;

uniform vec4 albedo : source_color = vec4(1.0);
uniform sampler2D albedo_texture : source_color, filter_nearest;
uniform bool clamp_diffuse_to_max = false;

// Triplanar Mapping Controls
uniform bool use_triplanar = false;
uniform float triplanar_scale = 1.0;
uniform float triplanar_sharpness : hint_range(0.0, 5.0) = 1.0;

// Ambient Occlusion
uniform bool use_ambient_occlusion = true;
uniform sampler2D ambient_occlusion_map : hint_default_white, filter_nearest;

uniform int cuts : hint_range(1, 8) = 3;
uniform float wrap : hint_range(-2.0, 2.0) = 0.0;
uniform float steepness : hint_range(1.0, 8.0) = 1.0;

uniform bool use_attenuation = true;

uniform bool use_specular = true;
uniform float specular_strength : hint_range(0.0, 1.0) = 1.0;
uniform float specular_shininess : hint_range(0.0, 32.0) = 16.0;
uniform sampler2D specular_map : hint_default_white, filter_nearest;

uniform bool use_rim = true;
uniform float rim_width : hint_range(0.0, 16.0) = 8.0;
uniform vec4 rim_color : source_color = vec4(1.0);

uniform bool use_ramp = false;
uniform sampler2D ramp : source_color;

uniform bool use_borders = false;
uniform float border_width = 0.01;

varying vec3 world_pos;
varying vec3 world_normal;

float split_specular(float specular) {
	return step(0.5, specular);
}

vec3 triplanar_sample(sampler2D tex, float scale) {
	vec3 blend_weights = abs(world_normal);
	blend_weights = pow(blend_weights, vec3(triplanar_sharpness));
	blend_weights = blend_weights / (blend_weights.x + blend_weights.y + blend_weights.z);

	vec2 uv_x = world_pos.yz * scale;
	vec2 uv_y = world_pos.xz * scale;
	vec2 uv_z = world_pos.xy * scale;
	
	vec3 tex_x = texture(tex, uv_x).rgb;
	vec3 tex_y = texture(tex, uv_y).rgb;
	vec3 tex_z = texture(tex, uv_z).rgb;

	return tex_x * blend_weights.x + tex_y * blend_weights.y + tex_z * blend_weights.z;
}

float triplanar_sample_single(sampler2D tex, float scale) {
	vec3 blend_weights = abs(world_normal);
	blend_weights = pow(blend_weights, vec3(triplanar_sharpness));
	blend_weights = blend_weights / (blend_weights.x + blend_weights.y + blend_weights.z);

	vec2 uv_x = world_pos.yz * scale;
	vec2 uv_y = world_pos.xz * scale;
	vec2 uv_z = world_pos.xy * scale;
	
	float tex_x = texture(tex, uv_x).r;
	float tex_y = texture(tex, uv_y).r;
	float tex_z = texture(tex, uv_z).r;

	return tex_x * blend_weights.x + tex_y * blend_weights.y + tex_z * blend_weights.z;
}

void vertex() {
	world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	world_normal = normalize(mat3(MODEL_MATRIX) * NORMAL);
}

void fragment() {
	vec3 albedo_tex;
	float ao_value = 1.0; // Default to 1.0 (no occlusion)
	
	if (use_triplanar) {
		albedo_tex = triplanar_sample(albedo_texture, triplanar_scale);
		if (use_ambient_occlusion) {
			ao_value = triplanar_sample_single(ambient_occlusion_map, triplanar_scale);
		}
	} else {
		albedo_tex = texture(albedo_texture, UV).rgb;
		if (use_ambient_occlusion) {
			ao_value = texture(ambient_occlusion_map, UV).r;
		}
	}
	
	// Apply the albedo texture and the ambient occlusion directly to the final ALBEDO
	ALBEDO = albedo.rgb * albedo_tex * ao_value;
	NORMAL = normalize(NORMAL);
}

void light() {
	vec3 normal = normalize(NORMAL);
	
	float attenuation = 1.0;
	if (use_attenuation) {
		attenuation = ATTENUATION;
	}
	
	float NdotL = dot(normal, LIGHT);
	float diffuse_amount = NdotL + (attenuation - 1.0) + wrap;
	diffuse_amount *= steepness;
	float cuts_inv = 1.0 / float(cuts);
	float diffuse_stepped = clamp(diffuse_amount + mod(1.0 - diffuse_amount, cuts_inv), 0.0, 1.0);

	float border = 0.0;
	if (use_borders) {
		float corr_border_width = length(cross(normal, LIGHT)) * border_width * steepness;
		border = step(diffuse_stepped - corr_border_width, diffuse_amount)
				 - step(1.0 - corr_border_width, diffuse_amount);
	}
	
	// Note: We no longer multiply by ao_value here
	vec3 diffuse = ALBEDO.rgb * LIGHT_COLOR;
	if (use_ramp) {
		diffuse *= texture(ramp, vec2(diffuse_stepped * (1.0 - border), 0.0)).rgb;
	} else {
		diffuse *= diffuse_stepped * (1.0 - border);
	}
	
	if (clamp_diffuse_to_max) {
		DIFFUSE_LIGHT = max(DIFFUSE_LIGHT, diffuse);
	} else {
		DIFFUSE_LIGHT += diffuse;
	}
	
	if (use_specular) {
		vec3 H = normalize(LIGHT + VIEW);
		float NdotH = dot(normal, H);
		
		float specular_value;
		if (use_triplanar) {
			specular_value = triplanar_sample_single(specular_map, triplanar_scale);
		} else {
			specular_value = texture(specular_map, UV).r;
		}
		
		float specular_amount = max(pow(NdotH, specular_shininess*specular_shininess), 0.0)
							    * specular_value
								* attenuation;
		specular_amount = split_specular(specular_amount);
		SPECULAR_LIGHT += specular_strength * specular_amount * LIGHT_COLOR;
	}
	
	if (use_rim) {
		float NdotV = dot(normal, VIEW);
		float rim_light = pow(1.0 - NdotV, rim_width);
		SPECULAR_LIGHT += rim_light * rim_color.rgb * rim_color.a * LIGHT_COLOR / PI;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_apodb"]
render_priority = 0
shader = SubResource("Shader_duuov")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/albedo_texture = ExtResource("2_y62cx")
shader_parameter/clamp_diffuse_to_max = true
shader_parameter/use_triplanar = false
shader_parameter/triplanar_scale = 0.02
shader_parameter/triplanar_sharpness = 1.515
shader_parameter/use_ambient_occlusion = false
shader_parameter/ambient_occlusion_map = ExtResource("3_ap11n")
shader_parameter/cuts = 4
shader_parameter/wrap = -0.0509999
shader_parameter/steepness = 1.479
shader_parameter/use_attenuation = true
shader_parameter/use_specular = true
shader_parameter/specular_strength = 0.128
shader_parameter/specular_shininess = 0.0
shader_parameter/specular_map = ExtResource("4_wbtk3")
shader_parameter/use_rim = false
shader_parameter/rim_width = 6.488
shader_parameter/rim_color = Color(0.190762, 0.190762, 0.190762, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="Shader" id="Shader_0opxd"]
code = "shader_type spatial;

//render_mode ambient_light_disabled;

uniform vec4 albedo : source_color = vec4(1.0);
uniform sampler2D albedo_texture : source_color, filter_nearest;
uniform bool clamp_diffuse_to_max = false;

// Triplanar Mapping Controls
uniform bool use_triplanar = false;
uniform float triplanar_scale = 1.0;
uniform float triplanar_sharpness : hint_range(0.0, 5.0) = 1.0;

// Ambient Occlusion
uniform bool use_ambient_occlusion = true;
uniform sampler2D ambient_occlusion_map : hint_default_white, filter_nearest;

uniform int cuts : hint_range(1, 8) = 3;
uniform float wrap : hint_range(-2.0, 2.0) = 0.0;
uniform float steepness : hint_range(1.0, 8.0) = 1.0;

uniform bool use_attenuation = true;

uniform bool use_specular = true;
uniform float specular_strength : hint_range(0.0, 1.0) = 1.0;
uniform float specular_shininess : hint_range(0.0, 32.0) = 16.0;
uniform sampler2D specular_map : hint_default_white, filter_nearest;

uniform bool use_rim = true;
uniform float rim_width : hint_range(0.0, 16.0) = 8.0;
uniform vec4 rim_color : source_color = vec4(1.0);

uniform bool use_ramp = false;
uniform sampler2D ramp : source_color;

uniform bool use_borders = false;
uniform float border_width = 0.01;

varying vec3 world_pos;
varying vec3 world_normal;

float split_specular(float specular) {
	return step(0.5, specular);
}

vec3 triplanar_sample(sampler2D tex, float scale) {
	vec3 blend_weights = abs(world_normal);
	blend_weights = pow(blend_weights, vec3(triplanar_sharpness));
	blend_weights = blend_weights / (blend_weights.x + blend_weights.y + blend_weights.z);

	vec2 uv_x = world_pos.yz * scale;
	vec2 uv_y = world_pos.xz * scale;
	vec2 uv_z = world_pos.xy * scale;
	
	vec3 tex_x = texture(tex, uv_x).rgb;
	vec3 tex_y = texture(tex, uv_y).rgb;
	vec3 tex_z = texture(tex, uv_z).rgb;

	return tex_x * blend_weights.x + tex_y * blend_weights.y + tex_z * blend_weights.z;
}

float triplanar_sample_single(sampler2D tex, float scale) {
	vec3 blend_weights = abs(world_normal);
	blend_weights = pow(blend_weights, vec3(triplanar_sharpness));
	blend_weights = blend_weights / (blend_weights.x + blend_weights.y + blend_weights.z);

	vec2 uv_x = world_pos.yz * scale;
	vec2 uv_y = world_pos.xz * scale;
	vec2 uv_z = world_pos.xy * scale;
	
	float tex_x = texture(tex, uv_x).r;
	float tex_y = texture(tex, uv_y).r;
	float tex_z = texture(tex, uv_z).r;

	return tex_x * blend_weights.x + tex_y * blend_weights.y + tex_z * blend_weights.z;
}

void vertex() {
	world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	world_normal = normalize(mat3(MODEL_MATRIX) * NORMAL);
}

void fragment() {
	vec3 albedo_tex;
	float ao_value = 1.0; // Default to 1.0 (no occlusion)
	
	if (use_triplanar) {
		albedo_tex = triplanar_sample(albedo_texture, triplanar_scale);
		if (use_ambient_occlusion) {
			ao_value = triplanar_sample_single(ambient_occlusion_map, triplanar_scale);
		}
	} else {
		albedo_tex = texture(albedo_texture, UV).rgb;
		if (use_ambient_occlusion) {
			ao_value = texture(ambient_occlusion_map, UV).r;
		}
	}
	
	// Apply the albedo texture and the ambient occlusion directly to the final ALBEDO
	ALBEDO = albedo.rgb * albedo_tex * ao_value;
	NORMAL = normalize(NORMAL);
}

void light() {
	vec3 normal = normalize(NORMAL);
	
	float attenuation = 1.0;
	if (use_attenuation) {
		attenuation = ATTENUATION;
	}
	
	float NdotL = dot(normal, LIGHT);
	float diffuse_amount = NdotL + (attenuation - 1.0) + wrap;
	diffuse_amount *= steepness;
	float cuts_inv = 1.0 / float(cuts);
	float diffuse_stepped = clamp(diffuse_amount + mod(1.0 - diffuse_amount, cuts_inv), 0.0, 1.0);

	float border = 0.0;
	if (use_borders) {
		float corr_border_width = length(cross(normal, LIGHT)) * border_width * steepness;
		border = step(diffuse_stepped - corr_border_width, diffuse_amount)
				 - step(1.0 - corr_border_width, diffuse_amount);
	}
	
	// Note: We no longer multiply by ao_value here
	vec3 diffuse = ALBEDO.rgb * LIGHT_COLOR;
	if (use_ramp) {
		diffuse *= texture(ramp, vec2(diffuse_stepped * (1.0 - border), 0.0)).rgb;
	} else {
		diffuse *= diffuse_stepped * (1.0 - border);
	}
	
	if (clamp_diffuse_to_max) {
		DIFFUSE_LIGHT = max(DIFFUSE_LIGHT, diffuse);
	} else {
		DIFFUSE_LIGHT += diffuse;
	}
	
	if (use_specular) {
		vec3 H = normalize(LIGHT + VIEW);
		float NdotH = dot(normal, H);
		
		float specular_value;
		if (use_triplanar) {
			specular_value = triplanar_sample_single(specular_map, triplanar_scale);
		} else {
			specular_value = texture(specular_map, UV).r;
		}
		
		float specular_amount = max(pow(NdotH, specular_shininess*specular_shininess), 0.0)
							    * specular_value
								* attenuation;
		specular_amount = split_specular(specular_amount);
		SPECULAR_LIGHT += specular_strength * specular_amount * LIGHT_COLOR;
	}
	
	if (use_rim) {
		float NdotV = dot(normal, VIEW);
		float rim_light = pow(1.0 - NdotV, rim_width);
		SPECULAR_LIGHT += rim_light * rim_color.rgb * rim_color.a * LIGHT_COLOR / PI;
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_rw3en"]
render_priority = 0
shader = SubResource("Shader_0opxd")
shader_parameter/albedo = Color(1, 1, 1, 1)
shader_parameter/albedo_texture = ExtResource("5_873ek")
shader_parameter/clamp_diffuse_to_max = true
shader_parameter/use_triplanar = false
shader_parameter/triplanar_scale = 0.02
shader_parameter/triplanar_sharpness = 1.515
shader_parameter/use_ambient_occlusion = false
shader_parameter/ambient_occlusion_map = ExtResource("3_ap11n")
shader_parameter/cuts = 4
shader_parameter/wrap = -0.0509999
shader_parameter/steepness = 1.479
shader_parameter/use_attenuation = true
shader_parameter/use_specular = true
shader_parameter/specular_strength = 0.128
shader_parameter/specular_shininess = 0.0
shader_parameter/specular_map = ExtResource("6_vj0s6")
shader_parameter/use_rim = false
shader_parameter/rim_width = 6.488
shader_parameter/rim_color = Color(0.190762, 0.190762, 0.190762, 1)
shader_parameter/use_ramp = false
shader_parameter/use_borders = false
shader_parameter/border_width = 0.01

[sub_resource type="BoxShape3D" id="BoxShape3D_yohl2"]
size = Vector3(0.487793, 3.22949, 3.94629)

[node name="book_shelf" instance=ExtResource("1_yohl2")]

[node name="bookshelf" parent="." index="0"]
transform = Transform3D(0, 0, 1, 0, 1, 0, -1, 0, 0, -0.302365, -0.377063, -0.0513654)
surface_material_override/0 = SubResource("ShaderMaterial_apodb")
surface_material_override/1 = SubResource("ShaderMaterial_rw3en")

[node name="StaticBody3D" type="StaticBody3D" parent="." index="1"]

[node name="CollisionShape3D" type="CollisionShape3D" parent="StaticBody3D" index="0"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.256104, 1.24927, 0)
shape = SubResource("BoxShape3D_yohl2")
